# 图片上传功能优化深度解析

## 1. 问题背景

在使用 Base64 方案实现图片上传时，我们遇到了两个核心问题：

1.  **编辑器体验问题**：Base64 编码后的字符串非常长，当它被直接插入到编辑器（如 CodeMirror）中时，会占据大量空间，严重影响用户的编辑体验。
2.  **预览显示问题**：上传的原始图片尺寸可能很大，导致在预览区域显示时超出可视范围，破坏了页面的布局和可读性。

## 2. 解决方案设计

为了系统性地解决这些问题，我们设计了一个三位一体的综合优化方案：

-   **前端压缩**：在图片上传时，直接在浏览器端对图片进行压缩，从源头上减小图片数据的大小。
-   **简化显示与数据映射**：在编辑器中不显示原始的 Base64 字符串，而是显示一个简短的、人类可读的占位符。同时，使用一个 `Map` 结构将占位符与真实的 Base64 数据关联起来。
-   **CSS 样式控制**：通过为预览区的图片元素设置 `max-width` 和 `max-height`，确保任何尺寸的图片都能在预览区内以合适的大小显示。

## 3. 技术实现细节

### 3.1. 图片压缩

我们通过 `canvas` API 来实现图片压缩。

-   **核心逻辑**：
    1.  创建一个 `Image` 对象并加载用户选择的文件。
    2.  在 `onload` 回调中，根据预设的最大宽度（如 `800px`）计算出按比例缩放后的尺寸。
    3.  将 `canvas` 的尺寸设置为缩放后的尺寸。
    4.  使用 `ctx.drawImage()` 将图片绘制到 `canvas` 上。
    5.  调用 `canvas.toDataURL('image/jpeg', quality)` 导出带有压缩质量（如 `0.8`）的 Base64 字符串。

### 3.2. 占位符与数据映射

这是提升编辑器体验的关键。

-   **生成占位符**：
    -   为每个上传的图片生成一个唯一的 ID，例如 `img_timestamp_random`。
    -   在编辑器中插入的 Markdown 文本是 `![图片原名](📷 unique_id)` 格式。`📷` 符号可以直观地告诉用户这是一个图片占位符。

-   **数据存储**：
    -   在 Pinia store (`useEditorStore`) 中维护一个 `imageMap: Map<string, string>`。
    -   `key` 是图片的唯一 ID，`value` 是压缩后的 Base64 字符串。
    -   当图片上传时，将 ID 和 Base64 数据存入 `imageMap`。

### 3.3. 解析器适配

为了让预览区能正确显示图片，需要让我们的 Markdown 解析器能够识别占位符。

-   **渲染逻辑**：
    -   在解析 `image` 类型的节点时，检查其 `src` 是否以 `📷 ` 开头。
    -   如果是，则从 `src` 中提取出图片 ID。
    -   使用该 ID 从 Pinia store 的 `imageMap` 中获取真实的 Base64 数据。
    -   用真实的 Base64 数据渲染 `<img>` 标签。
    -   如果不是占位符，则按原逻辑处理。

### 3.4. 预览样式优化

通过在全局 CSS 文件 (`src/style.css`) 中添加样式来约束图片显示。

```css
.mini-vue-md-image {
  max-width: 100%;
  max-height: 400px; /* 关键：限制最大高度 */
  object-fit: contain; /* 关键：保持图片原始比例，避免拉伸变形 */
  display: block;
  margin: 10px auto;
  border: 1px solid var(--image-border);
  border-radius: 3px;
  padding: 5px;
}
```

## 4. 性能与内存管理

长时间使用编辑器可能会导致 `imageMap` 中积累大量不再被使用的图片数据，造成内存泄漏。

-   **清理机制**：
    -   我们设计了 `clearUnusedImages` 函数。
    -   该函数会遍历当前编辑器中的所有文本，用正则表达式找出所有正在被使用的图片 ID。
    -   然后，它会遍历 `imageMap`，将所有不在使用列表中的图片数据从 Map 中删除，从而释放内存。
-   **调用时机**：
    -   可以在用户保存内容、切换文档或者定期（如每隔几分钟）调用此函数。

## 5. 总结与展望

该方案通过前端压缩、数据与显示分离、样式约束和内存管理，系统性地解决了 Base64 图片上传带来的各种问题，显著提升了用户体验和应用性能。

-   **未来可扩展方向**：
    -   **服务器上传**：如果未来需要支持图片持久化存储，只需将 `handleImageUpload` 中的 Base64 生成逻辑替换为向服务器上传的 API 调用即可，上层逻辑无需改动。
    -   **图片懒加载**：对于非常长的文档，可以结合 `IntersectionObserver` 实现预览区图片的懒加载，进一步优化性能。
